using Raylib_cs;

namespace Nescli;

/// <summary>
/// Represents the Picture Processing Unit inside an NES. It has its own memory map
/// and an internal 256x240px framebuffer for the screen.
/// </summary>
public class Ppu
{
    private readonly MemoryController _mc;
    private readonly Color[,] _frameBuffer;
    private ushort _baseNametableAddress;
    private bool _nmiFlag;
    private bool _spriteZeroHitFlag;
    private bool _spriteOverflowFlag;

    /// <summary>
    /// Constructs a new PPU and sets its framebuffer to a black screen
    /// </summary>
    /// <param name="mc">The memory controller to attach</param>
    public Ppu(MemoryController mc)
    {
        _mc = mc;
        _frameBuffer = new Color[256, 240];
        for (var i = 0; i < _frameBuffer.GetLength(0); i++)
        {
            for (var j = 0; j < _frameBuffer.GetLength(1); j++)
            {
                _frameBuffer[i, j] = new Color(0, 0, 0, 255);
            }
        }
    }

    /// <summary>
    /// Control register accessed by the CPU over the data bus
    /// </summary>
    /// <param name="value">Value on the bus</param>
    public void WritePpuCtrl(byte value)
    {
        _baseNametableAddress = (value & 0b11) switch
        {
            0 => 0x2000,
            1 => 0x2400,
            2 => 0x2800,
            3 => 0x2c00,
            _ => 0 // so the linter stops complaining about non-exhaustive switches
        };
    }

    /// <summary>
    /// Gets the status of the PPU, to inform the CPU where the rendering process is
    /// </summary>
    /// <returns>The status bits, see NesDev wiki</returns>
    public byte ReadPpuStatus()
    {
        var ret = (_nmiFlag ? 0x80 : 0)
                  | (_spriteZeroHitFlag ? 0x40 : 0)
                  | (_spriteOverflowFlag ? 0x20 : 0);
        return (byte)ret;
    }

    /// <summary>
    /// Fills the framebuffer with the CHR Rom as a big spritesheet, for debug purposes
    /// </summary>
    public void GenerateSpritesheet()
    {
        for (ushort i = 0; i < 0x2000; i += 16)
        {
            ulong l1 = _mc.Read64(i);
            ulong l2 = _mc.Read64((ushort)(i + 8));

            // The x offset for a sprite needs to increase by 8 for every 8 pixels across
            // 'i' increments by 16 for every 8 pixels, hence dividing by 2 and truncating
            // to screen width
            var xOffset = i / 2 % 256;

            // The y offset for a sprite needs to increase by 8 for every 256 pixels across
            // Again dividing by 2 to get an increase of 8 per sprite, dividing by 256 to get
            // an increase of 1 per 32 sprites (=256 pixels) and multiply by 8
            // to get 8 pixels per row of sprites
            var yOffset = i / 2 / 256 * 8;

            var x = 0;
            var y = 0;
            for (var j = 63; j >= 0; j--)
            {
                if ((l1 & (1ul << j)) != 0)
                {
                    if ((l2 & (1ul << j)) != 0)
                    {
                        // y is always stepped through in reverse, since y screen coordinates
                        // are flipped compared to the internal model of the CHR data
                        _frameBuffer[xOffset + x, yOffset + (7 - y)] = new Color(0x0, 0x0, 0x0, 0xff);
                    }
                    else
                    {
                        _frameBuffer[xOffset + x, yOffset + (7 - y)] = new Color(0x80, 0x80, 0x80, 0xff);
                    }
                }
                else
                {
                    if ((l2 & (1ul << j)) != 0)
                    {
                        _frameBuffer[xOffset + x, yOffset + (7 - y)] = new Color(0x40, 0x40, 0x40, 0xff);
                    }
                    else
                    {
                        _frameBuffer[xOffset + x, yOffset + (7 - y)] = new Color(0xc0, 0xc0, 0xc0, 0xff);
                    }
                }

                x++;
                if (x != 8) continue;
                x %= 8;
                y++;
            }
        }
    }

    /// <summary>
    /// Initializes the drawing routine, emulating the 256x240 video output generated by the PPU
    /// </summary>
    public void StartRendering()
    {
        // The PPU renders a total of 262 scan lines per frame, and calls the NMI on the CPU
        // once it enters the 241st. 241-262 are not visible, since they do not fit in the NES' resolution.
        // This makes the window between 241 and 262 theoretically the only safe place to write to
        // the PPU from the CPU, hence the NMI.

        Task.Run(() =>
        {
            Raylib.InitWindow(256, 240, "nes");
            Raylib.SetTargetFPS(60);
            while (!Raylib.WindowShouldClose())
            {
                _nmiFlag = false;
                _spriteZeroHitFlag = false;
                _spriteOverflowFlag = false;
                Raylib.BeginDrawing();
                for (var i = 0; i < _frameBuffer.GetLength(0); i++)
                {
                    for (var j = 0; j < _frameBuffer.GetLength(1); j++)
                    {
                        Raylib.DrawPixel(i, j, _frameBuffer[i, j]);
                    }
                }

                Raylib.EndDrawing();
                _nmiFlag = true;
            }

            Raylib.CloseWindow();
        });
    }
}